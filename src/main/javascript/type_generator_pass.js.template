  function TypeGeneratorPass(typeManager) {
    /* Pumpkin Spice has implied, static typing

       Certain types of expressions have a specific type
       FOR loop variables are numeric, for example

       Certain types of expressions have the same type
       as their counterpart.
       IF statements compare two expressions of the same type, for example

       A variable that's not used might not have a type
       Anything that's used ends up with a type

    */

/***********************************************************************
  BEGIN Type Gen functions
***********************************************************************/
    function trueFunc() {
      return true;
    }

    function printString(value,newline,pause,num) {
      return (value !== null && value !== undefined);
    }

    function printExp(exp,newline,pause,num) {
      var result = typeManager.genTypesForStringExpression(exp);
      if (!result) {
        logger.error("Type mismatch for PRINT on line "+num+"\n");
      }
      return result;
    }

    function ifStatement(boolExp,num){
      if (boolExp === null) {
        logger.error("Invalid comparison for IF on line "+num+"\n");
        return false;
      }
      return true;
    }

    function whileStatement(exp,num){
      if (exp === null) {
        logger.error("Type mismath for WHILE on line "+num+"\n");
        return false;
      }
      return true;
    }

    function beginSubroutine(name, args, num) {
      // XXX CHECK THAT VARIABLE HASN'T BEEN DEFINED
      // XXX WHEN VARS ARE DEFINED, CHECK THAT SUBROUTINE HASN'T BEEN DEFINED
      // If there's an existing subArgNames entry, this had already been defined!
      if (typeManager.subIsDefined(name)) {
        logger.error("SUBROUTINE "+name+" REDEFINED on line "+num+"\n");
        return false;
      } else {
        // This is the current sub now.
        currentSub = name;

        // We've never seen this before. Save the count, too
        if (typeManager.getSubArgCount(name) === undefined ||
            typeManager.getSubArgCount(name) == args.length) {
          typeManager.setSubArgNames(name, args);

        } else { // We've seen this called. Check that the param count matches.
          logger.error("SUBROUTINE "+name+" HAS "+args.length+" args but was called with "+typeManager.getSubArgCount(name)+" on line "+num+"\n");
          return false;
        }
        return true;
      }
    }

    function callSubroutine(name, argExps, num) {
      return typeManager.callSubroutineStatement(name, argExps);
    }

    function endSubroutine(num) {
      currentSub = undefined;
      return true;
    }

    function returnStatement(exp, num) {
      return typeManager.returnStatement(currentSub, exp);
    }

    function beginAsk(promptExp,num) {
      var result = typeManager.genTypesForStringExpression(promptExp);
      if (result === null) {
        logger.error("Type mismatch for ASK on line "+num+"\n");
        return false;
      } else {
        return true;
      }
    }

    function beginMenu(promptExp,num) {
      var result = typeManager.genTypesForStringExpression(promptExp);
      if (result === null) {
        logger.error("Type mismatch for BEGIN MENU on line "+num+"\n");
        return false;
      } else {
        return true;
      }
    }

    function menuChoice(charExp,textExp,num) {
      var result = typeManager.genTypesForStringExpression(textExp);
      if (result === null) {
        logger.error("Type mismatch for MENU CHOICE on line "+num+"\n");
        return false;
      } else {
        return true;
      }
    }

    function menuHideIf(boolExp,num) {
      if (boolExp === null) {
        logger.error("Type mismatch for HIDE IF on line "+num+"\n");
        return false;
      } else {
        return true;
      }
    }

    function color(valueExp,num) {
      var result = typeManager.genTypesForNumericExpression(valueExp);
      if (result === null) {
        logger.error("Type mismatch for COLOR on line "+num+"\n");
        return false;
      } else {
        return true;
      }
    }

    function bgColor(valueExp,num) {
      var result = typeManager.genTypesForNumericExpression(valueExp);
      if (result === null) {
        logger.error("Type mismatch for BGCOLOR on line "+num+"\n");
        return false;
      } else {
        return true;
      }
    }

    function sleep(valueExp,num) {
      var result = typeManager.genTypesForNumericExpression(valueExp);
      if (result === null) {
        logger.error("Type mismatch for SLEEP on line "+num+"\n");
        return false;
      } else {
        return true;
      }
    }

    function input(valueExp,num) {
      return typeManager.assignGlobalStringType(valueExp);
    }

    function play(valueExp,num) {
      var result = typeManager.genTypesForStringExpression(valueExp);
      if (result === null) {
	logger.error("Type mismatch for PLAY on line "+num+"\n");
	return false;
      } else {
	return true;
      }
    }

    function forStatement(varExp,startExp,endExp,num) {
      if (!typeManager.assignGlobalNumericType(varExp) ||
          typeManager.genTypesForNumericExpression(startExp)===null ||
          typeManager.genTypesForNumericExpression(endExp)===null) {
        logger.error("Type mismatch for FOR on line "+num+"\n");
      } else {
        return true;
      }

    }

    function letStatement(varExp,valueExp,num) {
      if (varExp === null || valueExp === null) {
        logger.error("Type mismatch for assignment to "+varExp+" on line "+num+"\n");
        return false;
      }
      if (typeManager.localVariableDefined(currentSub, varExp)) {
        logger.error("Local variable assignment not supported, yet!\n");
        return false;
      }
      // Value exp has an unknown type
      if (typeManager.isStringType(valueExp)) {
        if (!typeManager.assignGlobalStringType(varExp)) {
          logger.error("Type mismatch for assignment to "+varExp+" on line "+num+".\n");
          return false;
        } else
          return true;
      } else if (typeManager.isNumericType(valueExp)) {
        if (!typeManager.assignGlobalNumericType(varExp)) {
          logger.error("Type mismatch for assignment to "+varExp+" on line "+num+".\n");
          return false;
        } else
          return true;
      } else {
        // The variable has a type- set the arg based on that
        if (typeManager.globalHasStringType(varExp)) {
          return typeManager.assignUnknownsStringTypes(valueExp);
        } else if (typeManager.globalHasNumericType(varExp)) {
          return typeManager.assignUnknownsNumericType(valueExp);
        } else {
          // There are no types yet

          typeManager.addGlobalToUnassignedType(valueExp, varExp);
          return true;
        }
      }
    }

/***********************************************************************
  END Type Gen functions
***********************************************************************/

{{type_generator_expression_handler.js}}

    var expressionHandler = ExpressionHandler();

    return {
      expressionHandler: expressionHandler,
      printString: printString,
      printExp: printExp,
      ifStatement: ifStatement,
      endIf: trueFunc,
      elseStatement: trueFunc,
      endWhile: trueFunc,
      whileStatement: whileStatement,
      beginRandom: trueFunc,
      waitForMusic: trueFunc,
      beginSubroutine: beginSubroutine,
      callSubroutine: callSubroutine,
      endSubroutine: endSubroutine,
      returnStatement: returnStatement,
      endRandom: trueFunc,
      withChance: trueFunc,
      withEvenChance: trueFunc,
      beginAsk: beginAsk,
      askColor: trueFunc,
      askBGColor: trueFunc,
      askPromptColor: trueFunc,
      onNo: trueFunc,
      onYes: trueFunc,
      askDefault: trueFunc,
      endAsk: trueFunc,
      beginMenu: beginMenu,
      menuColor: trueFunc,
      menuBGColor: trueFunc,
      menuChoiceColor: trueFunc,
      menuPromptColor: trueFunc,
      endMenu: trueFunc,
      menuChoice: menuChoice,
      menuHideIf: menuHideIf,
      color: color,
      bgColor: bgColor,
      sleep: sleep,
      input: input,
      play: play,
      forStatement: forStatement,
      letStatement: letStatement,
      comment: trueFunc,
      clear: trueFunc,
      next: trueFunc
    };
  }

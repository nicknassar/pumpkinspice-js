function TypeManagerTests(display) {
  {{type_manager.js}}

  var successCount = 0;
  var errorCount = 0;

  // Failures for the CURRENT test
  var failures = [];

  function getSuccessCount() {
    return successCount;
  }

  function getErrorCount() {
    return errorCount;
  }

  function assert(test, message) {
    if (test !== true)
      failures.push(message);
  }

  var tests = [
    // BEGIN tests for global variables
    {
      description: "single global string",
      run: function(typeManager, logger) {
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("NAME")) !== null,
               "type was generated");
        assert(typeManager.validate(), "validates");

        assert(typeManager.globalHasStringType("NAME"),
               "string type is set");
        assert(!typeManager.globalHasNumericType("NAME"),
               "numeric type is not set");
        assert(typeManager.getStringGlobals().length === 1 &&
               typeManager.getStringGlobals().indexOf("NAME") === 0,
               "global is reported");
        assert(typeManager.getNumericGlobals().length === 0,
               "no other global variables found");
        assert(logger.getLog().length === 0,
               "Errors found: "+logger.getLog().join(", "));
      }
    },
    {
      description: "single global number",
      run: function(typeManager, logger) {
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("NUM")) !== null,
               "type was generated");
        assert(typeManager.validate(), "validates");

        assert(typeManager.globalHasNumericType("NUM"),
               "numeric type is set");
        assert(!typeManager.globalHasStringType("NUM"),
               "string type is not set");
        assert(typeManager.getNumericGlobals().length === 1 &&
               typeManager.getNumericGlobals().indexOf("NUM") === 0,
               "global is reported")
        assert(typeManager.getStringGlobals().length === 0,
               "no other global variables found");
        assert(logger.getLog().length === 0,
               "Errors found: "+logger.getLog().join(", "));
      }
    },
    {
      description: "ambiguous global - number then string",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("AMBIGUOUS")) !== null,
               "first type generates no errors");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("AMBIGUOUS")) === null,
               "second type generates a null");
        logger.setLineNumber(3);
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 && logger.getLog()[0][0] === 2,
               "expected error message is set on correct line");
      }
    },
    {
      description: "ambiguous global - string then number",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("AMBIGUOUS")) !== null,
               "first type generates no errors");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("AMBIGUOUS")) === null,
               "second type generates a null");
        logger.setLineNumber(3);
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 && logger.getLog()[0][0] === 2,
               "expected error message is set on correct line");
      }
    },
    {
      description: "ambiguous global - combined expression",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("TXT")) !== null,
               "first type generates no errors");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("NUM")) !== null,
               "second type generates no errors");
        logger.setLineNumber(3);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("NUM"),
                                                     typeManager.typeExpressionForGlobal("TXT")) === null,
               "combined type generates errors");
        logger.setLineNumber(4);
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 && logger.getLog()[0][0] === 3,
               "expected error message is set on correct line");
      }
    },
    {
      description: "boolean global",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForBoolExpression(typeManager.typeExpressionForGlobal("NUM")) === null,
               "setting global to bool type generates errors");
        logger.setLineNumber(2);
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 && logger.getLog()[0][0] === 1,
               "expected error message is set on correct line");
      }
    },
    {
      description: "indirect typing",
      run: function(typeManager, logger) {
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("D"),
                                                     typeManager.typeExpressionForGlobal("E")) !== null,
               "no problem generating types for pair D,E");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("B"),
                                                     typeManager.typeExpressionForGlobal("C")) !== null,
               "no problem generating types for pair B,C");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.typeExpressionForGlobal("B")) !== null,
               "no problem generating types for pair A,B");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("C"),
                                                     typeManager.typeExpressionForGlobal("D")) !== null,
               "no problem generating types for pair C,D");
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("A")) !== null,
               "no problem setting numeric type for A");

        assert(typeManager.validate(), "validates");
        assert(typeManager.globalHasNumericType("A"),
               "numeric type is set for A");
        assert(typeManager.globalHasNumericType("B"),
               "numeric type is set for B");
        assert(typeManager.globalHasNumericType("C"),
               "numeric type is set for C");
        assert(typeManager.globalHasNumericType("D"),
               "numeric type is set for D");
        assert(typeManager.globalHasNumericType("E"),
               "numeric type is set for E");
        assert(typeManager.getNumericGlobals().length === 5 &&
               typeManager.getNumericGlobals().indexOf("A") !== -1 &&
               typeManager.getNumericGlobals().indexOf("B") !== -1 &&
               typeManager.getNumericGlobals().indexOf("C") !== -1 &&
               typeManager.getNumericGlobals().indexOf("D") !== -1 &&
               typeManager.getNumericGlobals().indexOf("E") !== -1,
               "globals are reported")
        assert(typeManager.getStringGlobals().length === 0,
               "no other global variables found");
        assert(logger.getLog().length === 0,
               "Errors found: "+logger.getLog().join(", "));

      }
    },
    {
      description: "indirect typing with error",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("B"),
                                                     typeManager.typeExpressionForGlobal("C")) !== null,
               "no problem generating types for pair B,C");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.typeExpressionForGlobal("B")) !== null,
               "no problem generating types for pair A,B");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("C"),
                                                     typeManager.typeExpressionForGlobal("D")) !== null,
               "no problem generating types for pair C,D");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("D"),
                                                     typeManager.typeExpressionForGlobal("E")) !== null,
               "no problem generating types for pair D,E");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("A")) !== null,
               "no problem setting numeric type for A");
        logger.setLineNumber(3);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("E")) === null,
               "problem setting string type for E");
        logger.setLineNumber(4);
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 &&
               logger.getLog()[0][0] === 3,
               "error is logged");
      }
    },
    {
      description: "indirect typing with error #2",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("A")) !== null,
               "no problem setting numeric type for A");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("E")) !== null,
               "no problem setting string type for E");
        logger.setLineNumber(3);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("B"),
                                                     typeManager.typeExpressionForGlobal("C")) !== null,
               "no problem generating types for pair B,C");
        logger.setLineNumber(4);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.typeExpressionForGlobal("B")) !== null,
               "no problem generating types for pair A,B");
        logger.setLineNumber(5);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("C"),
                                                     typeManager.typeExpressionForGlobal("D")) !== null,
               "no problem generating types for pair C,D");
        logger.setLineNumber(6);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("D"),
                                                     typeManager.typeExpressionForGlobal("E")) === null,
               "problem generating types for pair D,E");
        logger.setLineNumber(7);
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 &&
               logger.getLog()[0][0] === 6,
               "error is logged");
      }
    },
    {
      description: "dead code variable",
      run: function(typeManager, logger) {
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.typeExpressionForGlobal("A")) !== null,
               "no problem generating types for pair A,A");

        assert(typeManager.validate(), "validates");
        assert(logger.getLog().length === 0,
               "no errors");
        assert(typeManager.getNumericGlobals().length === 0,
               "no numeric global variables");
        assert(typeManager.getStringGlobals().length === 0,
               "no string global variables");
        assert(logger.getLog().length === 0,
               "no errors");

        // Maybe we should provide a list of dead variables and semantics
      }
    },
    // END tests for global variables
    // BEGIN tests for subroutines
    {
      description: "subroutine with no args",
      run: function(typeManager, logger) {
        assert(typeManager.registerSubroutineDefinition("RUNME", []),
               "registration succsessful");
        assert(typeManager.typeExpressionForVoidReturnStatement("RUNME") !== null,
               "void return type");
        assert(typeManager.typeExpressionForCallSubroutine("RUNME", []) !== null,
               "called successfully");
        assert(typeManager.validate(),
               "validates");
        assert(typeManager.subHasReturnType("RUNME") && typeManager.subHasVoidReturnType("RUNME"),
               "sub has void return");
        assert(!(typeManager.subHasStringReturnType("RUNME") ||
                 typeManager.subHasNumericReturnType("RUNME")),
               "sub does not have a string or numeric return type");
        assert(typeManager.getSubArgNames("RUNME").length === 0,
               "sub has no args");
        assert(logger.getLog().length === 0,
               "no errors");
      }
    },
    {
      description: "subroutine with no args called before defined",
      run: function(typeManager, logger) {
        var callType = typeManager.typeExpressionForCallSubroutine("RUNME", []);
        assert(callType !== null &&
               typeManager.genTypesForExpressionPair(typeManager.stringTypeExpression(),callType) !== null,
               "called successfully");
        assert(typeManager.registerSubroutineDefinition("RUNME", []),
               "registration succsessful");
        assert(typeManager.typeExpressionForReturnStatement("RUNME", typeManager.stringTypeExpression()) !== null,
               "void return type");
        assert(typeManager.validate(),
               "validates");
        assert(typeManager.subHasReturnType("RUNME") && typeManager.subHasStringReturnType("RUNME"),
               "sub has void return");
        assert(!(typeManager.subHasVoidReturnType("RUNME") ||
                 typeManager.subHasNumericReturnType("RUNME")),
               "sub does not have a string or numeric return type");
        assert(typeManager.getSubArgNames("RUNME").length === 0,
               "sub has no args");
        assert(logger.getLog().length === 0,
               "no errors");
      }
    },
    {
      description: "subroutine with one arg",
      run: function(typeManager, logger) {
        assert(typeManager.registerSubroutineDefinition("RUNME", ["ARG1"]),
               "registration succsessful");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG1"),
                                                     typeManager.stringTypeExpression()) !== null,
               "arg successfully set to string");
        assert(typeManager.typeExpressionForReturnStatement("RUNME", typeManager.stringTypeExpression()) !== null,
               "string return type");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForCallSubroutine("RUNME", [typeManager.stringTypeExpression()]), typeManager.stringTypeExpression()) !== null,
               "called")
        assert(typeManager.validate(),
               "validates");
        assert(typeManager.subHasReturnType("RUNME") && typeManager.subHasStringReturnType("RUNME"),
               "sub has string return type");
        assert(!(typeManager.subHasVoidReturnType("RUNME") ||
                 typeManager.subHasNumericReturnType("RUNME")),
               "sub does not have a void or numeric return type");
        assert(typeManager.getSubArgNames("RUNME").length === 1 &&
               typeManager.getSubArgNames("RUNME")[0] === "ARG1",
               "sub has an arg");
        assert(typeManager.localVariableDefined("RUNME","ARG1") &&
               typeManager.localHasStringType("RUNME","ARG1"),
               "arg1 has string type");
        assert(!typeManager.localHasNumericType("RUNME","ARG1"),
               "arg1 is not numeric");
        assert(logger.getLog().length === 0,
               "no errors");
      }
    },
    {
      description: "subroutine with two args",
      run: function(typeManager, logger) {
        assert(typeManager.registerSubroutineDefinition("RUNME", ["ARG1", "ARG2"]),
               "registration succsessful");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG1"),
                                                     typeManager.numericTypeExpression()) !== null,
               "arg1 successfully set to number");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG2"),
                                                     typeManager.stringTypeExpression()) !== null,
               "arg2 successfully set to string");
        assert(typeManager.typeExpressionForReturnStatement("RUNME", typeManager.numericTypeExpression()) !== null,
               "string return type");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForCallSubroutine("RUNME", [typeManager.numericTypeExpression(), typeManager.stringTypeExpression()]), typeManager.numericTypeExpression()) !== null,
               "called")
        assert(typeManager.validate(),
               "validates");
        assert(typeManager.subHasReturnType("RUNME") && typeManager.subHasNumericReturnType("RUNME"),
               "sub has string return type");
        assert(!(typeManager.subHasVoidReturnType("RUNME") ||
                 typeManager.subHasStringReturnType("RUNME")),
               "sub does not have a void or numeric return type");
        assert(typeManager.getSubArgNames("RUNME").length === 2 &&
               typeManager.getSubArgNames("RUNME")[0] === "ARG1" &&
               typeManager.getSubArgNames("RUNME")[1] === "ARG2",
               "sub has 2 args");
        assert(typeManager.localVariableDefined("RUNME","ARG1") &&
               typeManager.localHasNumericType("RUNME","ARG1"),
               "arg1 has numeric type");
        assert(!typeManager.localHasStringType("RUNME","ARG1"),
               "arg1 is not string");
        assert(typeManager.localVariableDefined("RUNME","ARG2") &&
               typeManager.localHasStringType("RUNME","ARG2"),
               "arg2 has string type");
        assert(!typeManager.localHasNumericType("RUNME","ARG2"),
               "arg2 does not have numeric type");
        assert(logger.getLog().length === 0,
               "no errors");
      }
    },
    {
      description: "subroutine with three args",
      run: function(typeManager, logger) {
        assert(typeManager.registerSubroutineDefinition("RUNME", ["ARG1", "ARG2", "ARG3"]),
               "registration succsessful");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG2"),
                                                     typeManager.numericTypeExpression()) !== null,
               "arg2 successfully set to number");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG3"),
                                                     typeManager.stringTypeExpression()) !== null,
               "arg3 successfully set to string");
        assert(typeManager.typeExpressionForReturnStatement("RUNME", typeManager.numericTypeExpression()) !== null,
               "string return type");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForCallSubroutine("RUNME", [typeManager.typeExpressionForGlobal("FIRST"), typeManager.numericTypeExpression(), typeManager.stringTypeExpression()]), typeManager.numericTypeExpression()) !== null,
               "called")
        assert(typeManager.validate(),
               "validates");
        assert(typeManager.subHasReturnType("RUNME") && typeManager.subHasNumericReturnType("RUNME"),
               "sub has string return type");
        assert(!(typeManager.subHasVoidReturnType("RUNME") ||
                 typeManager.subHasStringReturnType("RUNME")),
               "sub does not have a void or numeric return type");
        assert(typeManager.getSubArgNames("RUNME").length === 3 &&
               typeManager.getSubArgNames("RUNME")[0] === "ARG1" &&
               typeManager.getSubArgNames("RUNME")[1] === "ARG2" &&
               typeManager.getSubArgNames("RUNME")[2] === "ARG3",
               "sub has 3 args");
        assert(typeManager.localVariableDefined("RUNME","ARG1") &&
               !(typeManager.localHasNumericType("RUNME","ARG1") ||
                 typeManager.localHasStringType("RUNME","ARG1")),
               "arg1 has no type");
        assert(typeManager.localVariableDefined("RUNME","ARG2") &&
               typeManager.localHasNumericType("RUNME","ARG2"),
               "arg2 has numeric type");
        assert(!typeManager.localHasStringType("RUNME","ARG2"),
               "arg2 does not have string type");
        assert(typeManager.localVariableDefined("RUNME","ARG3") &&
               typeManager.localHasStringType("RUNME","ARG3"),
               "arg3 has string type");
        assert(!typeManager.localHasNumericType("RUNME","ARG3"),
               "arg3 does not have numeric type");
        assert(logger.getLog().length === 0,
               "no errors");
      }
    },
    {
      description: "subroutine with mismatched arg",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.registerSubroutineDefinition("RUNME", ["ARG1", "ARG2", "ARG3"]),
               "registration succsessful");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG2"),
                                                     typeManager.numericTypeExpression()) !== null,
               "arg2 successfully set to number");
        logger.setLineNumber(3);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG3"),
                                                     typeManager.stringTypeExpression()) !== null,
               "arg3 successfully set to string");
        logger.setLineNumber(4);
        assert(typeManager.typeExpressionForReturnStatement("RUNME", typeManager.numericTypeExpression()) !== null,
               "string return type");
        logger.setLineNumber(5);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForCallSubroutine("RUNME", [typeManager.typeExpressionForGlobal("FIRST"), typeManager.stringTypeExpression(), typeManager.stringTypeExpression()]), typeManager.numericTypeExpression()) === null,
               "called")
        logger.setLineNumber(6);
        assert(!typeManager.validate(),
               "does not validate");
        assert(logger.getLog().length === 1 &&
               logger.getLog()[0][0] === 5,
               "error is logged");

      }
    },
    {
      description: "subroutine with mismatched arg called before definition",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForCallSubroutine("RUNME", [typeManager.typeExpressionForGlobal("FIRST"), typeManager.stringTypeExpression(), typeManager.stringTypeExpression()]), typeManager.numericTypeExpression()) !== null,
               "called")
        logger.setLineNumber(2);
        assert(typeManager.registerSubroutineDefinition("RUNME", ["ARG1", "ARG2", "ARG3"]),
               "registration succsessful");
        logger.setLineNumber(3);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG2"),
                                                     typeManager.numericTypeExpression()) === null,
               "arg2 cannot be set to number");
        logger.setLineNumber(4);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG3"),
                                                     typeManager.stringTypeExpression()) !== null,
               "arg3 successfully set to string");
        logger.setLineNumber(5);
        assert(typeManager.typeExpressionForReturnStatement("RUNME", typeManager.numericTypeExpression()) !== null,
               "string return type");
        logger.setLineNumber(6);
        assert(!typeManager.validate(),
               "does not validate");
        assert(logger.getLog().length === 1 &&
               logger.getLog()[0][0] === 3,
               "error is logged");
      }
    },
    {
      description: "infer type from subroutine with subroutine expression arg",
      run: function(typeManager, logger) {
        assert(typeManager.registerSubroutineDefinition("ONEARG", ["ARG1"]),
               "registration succsessful");
        assert(typeManager.typeExpressionForReturnStatement("ONEARG", typeManager.typeExpressionForLocal("ONEARG","ARG1")) !== null,
               "returns argument");

        assert(typeManager.registerSubroutineDefinition("NOARG", []),
               "registration succsessful");
        assert(typeManager.typeExpressionForReturnStatement("NOARG", typeManager.typeExpressionForGlobal("B")) !== null,
               "returns global without a type");

        assert(typeManager.genTypesForExpressionPair(
          typeManager.typeExpressionForCallSubroutine("ONEARG", [typeManager.typeExpressionForCallSubroutine("NOARG",[])]),
          typeManager.typeExpressionForGlobal("A")) !== null,
               "called")

        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.stringTypeExpression()) !== null,
               "set A to string type");
        assert(typeManager.validate(),
               "validates");
        assert(typeManager.subHasReturnType("ONEARG") && typeManager.subHasStringReturnType("ONEARG"),
               "onearg sub has string return type");
        assert(typeManager.subHasReturnType("NOARG") && typeManager.subHasStringReturnType("NOARG"),
               "noarg sub has string return type");
        assert(!(typeManager.subHasVoidReturnType("ONEARG") ||
                 typeManager.subHasNumericReturnType("ONEARG")),
               "one arg sub does not have a void or numeric return type");
        assert(!(typeManager.subHasVoidReturnType("NOARG") ||
                 typeManager.subHasNumericReturnType("NOARG")),
               "no arg sub does not have a void or numeric return type");
        assert(typeManager.getSubArgNames("ONEARG").length === 1 &&
               typeManager.getSubArgNames("ONEARG")[0] === "ARG1",
               "one arg sub has an arg");
        assert(typeManager.getSubArgNames("NOARG").length === 0,
               "no arg sub has no arg");
        assert(typeManager.localVariableDefined("ONEARG","ARG1") &&
               typeManager.localHasStringType("ONEARG","ARG1"),
               "arg1 has string type");
        assert(!typeManager.localHasNumericType("ONEARG","ARG1"),
               "arg1 is not numeric");
        assert(typeManager.globalHasStringType("A"),
               "string type is set for A");
        assert(!typeManager.globalHasNumericType("A"),
               "numeric type is not set for A");
        assert(typeManager.globalHasStringType("B"),
               "string type is set for B");
        assert(!typeManager.globalHasNumericType("B"),
               "numeric type is not set for B");
        assert(typeManager.getNumericGlobals().length === 0,
               "no numeric globals reported");
        assert(typeManager.getStringGlobals().length === 2 &&
               typeManager.getStringGlobals().indexOf("A") !== -1 &&
               typeManager.getStringGlobals().indexOf("B") !== -1,
               "string globals reported");

        assert(logger.getLog().length === 0,
               "no errors");
      }
    },
    {
      description: "infer type conflict from subroutine with subroutine expression arg",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.registerSubroutineDefinition("ONEARG", ["ARG1"]),
               "registration succsessful");
        logger.setLineNumber(2);
        assert(typeManager.typeExpressionForReturnStatement("ONEARG", typeManager.typeExpressionForLocal("ONEARG","ARG1")) !== null,
               "returns argument");
        logger.setLineNumber(3);
        assert(typeManager.registerSubroutineDefinition("NOARG", []),
               "registration succsessful");
        logger.setLineNumber(4);
        assert(typeManager.typeExpressionForReturnStatement("NOARG", typeManager.typeExpressionForGlobal("B")) !== null,
               "returns global without type");
        logger.setLineNumber(5);
        assert(typeManager.genTypesForExpressionPair(
          typeManager.typeExpressionForCallSubroutine("ONEARG", [typeManager.typeExpressionForCallSubroutine("NOARG",[])]),
          typeManager.typeExpressionForGlobal("A")) !== null,
               "called");
        logger.setLineNumber(6);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("B"),
                                                     typeManager.numericTypeExpression()) !== null,
              "set B to numeric type");
        logger.setLineNumber(7);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.stringTypeExpression()) === null,
               "set A to string type fails");
        logger.setLineNumber(8);
        assert(!typeManager.validate(),
               "does not validate");

        assert(logger.getLog().length === 1 &&
               logger.getLog()[0][0] === 7,
               "no errors"+logger.getLog().join("-"));

              }
      }
    // END tests for subroutines
  ];

  function printFailure(description, failures) {
    display.setColor(4);
    display.print("TestManager failed test \"");
    display.setColor(12);
    display.print(description);
    display.setColor(4);
    display.print("\":\n");

    for (var i=0;i<failures.length;i++) {
      display.setColor(7);
      display.print("Assertion \"");
      display.setColor(15);
      display.print(failures[i]);
      display.setColor(7);
      display.print("\" failed\n");
    }
    display.print("\n");
  }

  function check(typeManager, logger, test) {
    failures = [];

    test.run(typeManager, logger);
    if (failures.length > 0) {
      printFailure(test.description, failures);
      errorCount++;
    } else {
      successCount++;
    }
  }

  function run() {
    for (var i=0;i<tests.length;i++) {
      var test = tests[i];
      var logger = TestingLogger();
      var typeManager = TypeManager(logger);
      check(typeManager, logger, tests[i]);
    }
    display.sendUpdates();
  }

  return {
    run:run,
    getSuccessCount:getSuccessCount,
    getErrorCount:getErrorCount
  };
}

function TypeManagerTests(display) {
  {{type_manager.js}}

  var successCount = 0;
  var errorCount = 0;

  // Failures for the CURRENT test
  var failures = [];

  function getSuccessCount() {
    return successCount;
  }

  function getErrorCount() {
    return errorCount;
  }

  function assert(test, message) {
    if (test !== true)
      failures.push(message);
  }

  var tests = [
    // BEGIN tests for global variables
    {
      description: "single global string",
      run: function(typeManager, logger) {
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("NAME")) !== null,
               "type was generated");
        assert(typeManager.validate(), "validates");

        assert(typeManager.globalHasStringType("NAME"),
               "string type is set");
        assert(!typeManager.globalHasNumericType("NAME"),
               "numeric type is not set");
        assert(typeManager.getStringGlobals().length === 1 &&
               typeManager.getStringGlobals().indexOf("NAME") === 0,
               "global is reported");
        assert(typeManager.getNumericGlobals().length === 0,
               "no other global variables found");
        assert(logger.getLog().length === 0,
               "Errors found: "+logger.getLog().join(", "));
      }
    },
    {
      description: "single global number",
      run: function(typeManager, logger) {
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("NUM")) !== null,
               "type was generated");
        assert(typeManager.validate(), "validates");

        assert(typeManager.globalHasNumericType("NUM"),
               "numeric type is set");
        assert(!typeManager.globalHasStringType("NUM"),
               "string type is not set");
        assert(typeManager.getNumericGlobals().length === 1 &&
               typeManager.getNumericGlobals().indexOf("NUM") === 0,
               "global is reported")
        assert(typeManager.getStringGlobals().length === 0,
               "no other global variables found");
        assert(logger.getLog().length === 0,
               "Errors found: "+logger.getLog().join(", "));
      }
    },
    {
      description: "ambiguous global - number then string",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("AMBIGUOUS")) !== null,
               "first type generates no errors");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("AMBIGUOUS")) === null,
               "second type generates a null");
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 && logger.getLog()[0][0] === 2,
               "expected error message is set on correct line");
      }
    },
    {
      description: "ambiguous global - string then number",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("AMBIGUOUS")) !== null,
               "first type generates no errors");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("AMBIGUOUS")) === null,
               "second type generates a null");
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 && logger.getLog()[0][0] === 2,
               "expected error message is set on correct line");
      }
    },
    {
      description: "ambiguous global - combined expression",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("TXT")) !== null,
               "first type generates no errors");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("NUM")) !== null,
               "second type generates no errors");
        logger.setLineNumber(3);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("NUM"),
                                                     typeManager.typeExpressionForGlobal("TXT")) === null,
               "combined type generates errors");

        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 && logger.getLog()[0][0] === 3,
               "expected error message is set on correct line");
      }
    },
    {
      description: "boolean global",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForBoolExpression(typeManager.typeExpressionForGlobal("NUM")) === null,
               "setting global to bool type generates errors");
        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 && logger.getLog()[0][0] === 1,
               "expected error message is set on correct line");
      }
    },
    {
      description: "indirect typing",
      run: function(typeManager, logger) {
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("D"),
                                                     typeManager.typeExpressionForGlobal("E")) !== null,
               "no problem generating types for pair D,E");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("B"),
                                                     typeManager.typeExpressionForGlobal("C")) !== null,
               "no problem generating types for pair B,C");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.typeExpressionForGlobal("B")) !== null,
               "no problem generating types for pair A,B");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("C"),
                                                     typeManager.typeExpressionForGlobal("D")) !== null,
               "no problem generating types for pair C,D");
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("A")) !== null,
               "no problem setting numeric type for A");

        assert(typeManager.validate(), "validates");
        assert(typeManager.globalHasNumericType("A"),
               "numeric type is set for A");
        assert(typeManager.globalHasNumericType("B"),
               "numeric type is set for B");
        assert(typeManager.globalHasNumericType("C"),
               "numeric type is set for C");
        assert(typeManager.globalHasNumericType("D"),
               "numeric type is set for D");
        assert(typeManager.globalHasNumericType("E"),
               "numeric type is set for E");
        assert(typeManager.getNumericGlobals().length === 5 &&
               typeManager.getNumericGlobals().indexOf("A") !== -1 &&
               typeManager.getNumericGlobals().indexOf("B") !== -1 &&
               typeManager.getNumericGlobals().indexOf("C") !== -1 &&
               typeManager.getNumericGlobals().indexOf("D") !== -1 &&
               typeManager.getNumericGlobals().indexOf("E") !== -1,
               "globals are reported")
        assert(typeManager.getStringGlobals().length === 0,
               "no other global variables found");
        assert(logger.getLog().length === 0,
               "Errors found: "+logger.getLog().join(", "));

      }
    },
    {
      description: "indirect typing with error",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("B"),
                                                     typeManager.typeExpressionForGlobal("C")) !== null,
               "no problem generating types for pair B,C");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.typeExpressionForGlobal("B")) !== null,
               "no problem generating types for pair A,B");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("C"),
                                                     typeManager.typeExpressionForGlobal("D")) !== null,
               "no problem generating types for pair C,D");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("D"),
                                                     typeManager.typeExpressionForGlobal("E")) !== null,
               "no problem generating types for pair D,E");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("A")) !== null,
               "no problem setting numeric type for A");
        logger.setLineNumber(3);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("E")) === null,
               "problem setting string type for E");

        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 &&
               logger.getLog()[0][0] === 3,
               "error is logged");
      }
    },
    {
      description: "indirect typing with error #2",
      run: function(typeManager, logger) {
        logger.setLineNumber(1);
        assert(typeManager.genTypesForNumericExpression(typeManager.typeExpressionForGlobal("A")) !== null,
               "no problem setting numeric type for A");
        logger.setLineNumber(2);
        assert(typeManager.genTypesForStringExpression(typeManager.typeExpressionForGlobal("E")) !== null,
               "no problem setting string type for E");
        logger.setLineNumber(3);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("B"),
                                                     typeManager.typeExpressionForGlobal("C")) !== null,
               "no problem generating types for pair B,C");
        logger.setLineNumber(4);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.typeExpressionForGlobal("B")) !== null,
               "no problem generating types for pair A,B");
        logger.setLineNumber(5);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("C"),
                                                     typeManager.typeExpressionForGlobal("D")) !== null,
               "no problem generating types for pair C,D");
        logger.setLineNumber(6);
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("D"),
                                                     typeManager.typeExpressionForGlobal("E")) === null,
               "problem generating types for pair D,E");

        assert(!typeManager.validate(), "does not validate");
        assert(logger.getLog().length === 1 &&
               logger.getLog()[0][0] === 6,
               "error is logged");
      }
    },
    {
      description: "dead code variable",
      run: function(typeManager, logger) {
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForGlobal("A"),
                                                     typeManager.typeExpressionForGlobal("A")) !== null,
               "no problem generating types for pair A,A");

        assert(typeManager.validate(), "validates");
        assert(logger.getLog().length === 0,
               "no errors");
        assert(typeManager.getNumericGlobals().length === 0,
               "no numeric global variables");
        assert(typeManager.getStringGlobals().length === 0,
               "no string global variables");

        // Maybe we should provide a list of dead variables and semantics
      }
    },
    // END tests for global variables
    // BEGIN tests for subroutines
    {
      description: "subroutine with no args",
      run: function(typeManager, logger) {
        assert(typeManager.registerSubroutineDefinition("RUNME", []),
               "registration succsessful");
        assert(typeManager.typeExpressionForVoidReturnStatement("RUNME") !== null,
               "void return type");
        assert(typeManager.typeExpressionForCallSubroutine("RUNME", []) !== null,
               "called successfully");
        assert(typeManager.validate(),
               "validates");
        assert(typeManager.subHasReturnType("RUNME") && typeManager.subHasVoidReturnType("RUNME"),
               "sub has void return");
        assert(!(typeManager.subHasStringReturnType("RUNME") ||
                 typeManager.subHasNumericReturnType("RUNME")),
               "sub does not have a string or numeric return type");
        assert(typeManager.getSubArgNames("RUNME").length === 0,
               "sub has no args");
      }
    },
    // subroutine called before defined
    // subroutine called before defined with type
    {
      description: "subroutine with one arg",
      run: function(typeManager, logger) {
        assert(typeManager.registerSubroutineDefinition("RUNME", ["ARG1"]),
               "registration succsessful");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForLocal("RUNME","ARG1"),
                                                     typeManager.stringTypeExpression()) !== null,
               "arg successfully set to string");
        assert(typeManager.typeExpressionForReturnStatement("RUNME", typeManager.stringTypeExpression()) !== null,
               "string return type");
        assert(typeManager.genTypesForExpressionPair(typeManager.typeExpressionForCallSubroutine("RUNME", [typeManager.stringTypeExpression()]), typeManager.stringTypeExpression()) !== null,
               "called")
        assert(typeManager.validate(),
               "validates");
        assert(typeManager.subHasReturnType("RUNME") && typeManager.subHasStringReturnType("RUNME"),
               "sub has string return type");
        assert(!(typeManager.subHasVoidReturnType("RUNME") ||
                 typeManager.subHasNumericReturnType("RUNME")),
               "sub does not have a void or numeric return type");
        assert(typeManager.getSubArgNames("RUNME").length === 1 &&
               typeManager.getSubArgNames("RUNME")[0] === "ARG1",
               "sub has an arg");
        assert(typeManager.localVariableDefined("RUNME","ARG1") &&
               typeManager.localHasStringType("RUNME","ARG1"),
               "arg1 has string type");
        assert(!typeManager.localHasNumericType("RUNME","ARG1"),
               "arg1 is not numeric");
      }
    }
    // subroutine with
    // subroutine with two args
    // subroutine with three args
    // subroutine called with invalid args
    // type graphs with globals, args, and return types
    // END tests for subroutines
  ];

  function printFailure(description, failures) {
    display.setColor(4);
    display.print("TestManager failed test \"");
    display.setColor(12);
    display.print(description);
    display.setColor(4);
    display.print("\":\n");

    for (var i=0;i<failures.length;i++) {
      display.setColor(7);
      display.print("Assertion \"");
      display.setColor(15);
      display.print(failures[i]);
      display.setColor(7);
      display.print("\" failed\n");
    }
    display.print("\n");
  }

  function check(typeManager, logger, test) {
    failures = [];

    test.run(typeManager, logger);
    if (failures.length > 0) {
      printFailure(test.description, failures);
      errorCount++;
    } else {
      successCount++;
    }
  }

  function run() {
    for (var i=0;i<tests.length;i++) {
      var test = tests[i];
      var logger = TestingLogger();
      var typeManager = TypeManager(logger);
      check(typeManager, logger, tests[i]);
    }
    display.sendUpdates();
  }

  return {
    run:run,
    getSuccessCount:getSuccessCount,
    getErrorCount:getErrorCount
  };
}

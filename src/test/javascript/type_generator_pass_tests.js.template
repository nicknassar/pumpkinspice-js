function TypeGeneratorPassTests(display) {
  {{type_generator_pass.js}}
  {{testing_type_manager.js}}

  // variables reset for each run
  var logger;
  var typeManager;
  var typeGeneratorPass;
  function setup() {
    logger = TestingLogger();
    typeManager = TestingTypeManager();
    typeGeneratorPass = TypeGeneratorPass(typeManager, logger);
  }

  // List of objects with description, function to run, the expected
  // calls into the type manager, and the expected errors

  // The testing type manager returns the number of
  // an expression. The values that are from expressions
  // refer to the order in which handler functions were called
  var expectations = [
    {
      description: "Hello World",
      run: function() {
        typeGeneratorPass.printString("Hello World!", true, false);
        typeGeneratorPass.finalize();
      },
      calls: [
        ["validate"]
      ],
      errors: []
    },
    {
      description: "PRINT paren expression",
      run: function() {
        typeGeneratorPass.printExp(
          typeGeneratorPass.parenExpression(
            typeGeneratorPass.stringLiteralExpression("somestring")), true, false);
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["typeForStringExpression", 0],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "PRINT double paren expression",
      run: function() {
        typeGeneratorPass.printExp(
          typeGeneratorPass.parenExpression(
            typeGeneratorPass.parenExpression(
              typeGeneratorPass.stringLiteralExpression("somestring"))), true, false);
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["typeForStringExpression", 0],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "PRINT string concatenation expression",
      run: function() {
        typeGeneratorPass.printExp(
          typeGeneratorPass.additionExpression(
            typeGeneratorPass.stringLiteralExpression("string"),
            typeGeneratorPass.stringLiteralExpression("string")
          ),
          true,
          false);
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["stringType"],
        ["typeForPair", 0, 1],
        ["typeForStringExpression", 2],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "PRINT string multi concatenation expression",
      run: function() {
        typeGeneratorPass.printExp(
          typeGeneratorPass.additionExpression(
            typeGeneratorPass.stringLiteralExpression("string"),
            typeGeneratorPass.stringLiteralExpression("string")
          ),
          true,
          false);
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["stringType"],
        ["typeForPair", 0, 1],
        ["typeForStringExpression", 2],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "PRINT variable",
      run: function() {
        typeGeneratorPass.printExp(
          typeGeneratorPass.variableExpression("VARIABLE"),
          true,
          false);
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "VARIABLE"],
        ["typeForStringExpression", 0],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "PRINT variable+literal",
      run: function() {
        typeGeneratorPass.printExp(
          typeGeneratorPass.additionExpression(
            typeGeneratorPass.variableExpression("VARIABLE"),
            typeGeneratorPass.stringLiteralExpression("Literally")
          ),
          true,
          false);
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "VARIABLE"],
        ["stringType"],
        ["typeForPair", 0, 1],
        ["typeForStringExpression", 2],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "COLOR statement",
      run: function() {
        typeGeneratorPass.color(
          typeGeneratorPass.numericLiteralExpression("7"));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "COLOR statement with expression",
      run: function() {
        typeGeneratorPass.color(
          typeGeneratorPass.additionExpression(
            typeGeneratorPass.numericLiteralExpression("7"),
            typeGeneratorPass.variableExpression("X")
          ));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForGlobal", "X"],
        ["typeForPair", 0, 1],
        ["typeForNumericExpression", 2],
        ["validate"]
      ],
      errors: []

    },
    {
      description: "BGCOLOR statement",
      run: function() {
        typeGeneratorPass.bgColor(
          typeGeneratorPass.numericLiteralExpression("7"));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "BGCOLOR statement with expression",
      run: function() {
        typeGeneratorPass.bgColor(
          typeGeneratorPass.additionExpression(
            typeGeneratorPass.numericLiteralExpression("7"),
            typeGeneratorPass.variableExpression("X")
          ));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForGlobal","X"],
        ["typeForPair", 0, 1],
        ["typeForNumericExpression", 2],
        ["validate"]
      ],
      errors: []

    },
    {
      description: "CLEAR statement",
      run: function() {
        typeGeneratorPass.clear();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["validate"]
      ],
      errors: []
    },
    {
      description: "INPUT statement",
      run: function() {
        typeGeneratorPass.input("Q");
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "Q"],
        ["typeForStringExpression", 0],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "PLAY statement",
      run: function() {
        typeGeneratorPass.play(typeGeneratorPass.stringLiteralExpression("ABC"));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["typeForStringExpression", 0],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Sleep statement",
      run: function() {
        typeGeneratorPass.sleep(typeGeneratorPass.numericLiteralExpression(7));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.variableExpression("B"));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "B"],
        ["typeForGlobal", "A"],
        ["typeForPair", 0, 1],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from string literal",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.stringLiteralExpression("B"));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 0, 1],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from numeric literal",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.numericLiteralExpression("1"));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 0, 1],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from numeric addition",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.additionExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"),
                                         typeGeneratorPass.numericLiteralExpression("2"))
                                       );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["numericType"],
        ["typeForPair", 0, 1],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from string addition",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.additionExpression(
                                         typeGeneratorPass.stringLiteralExpression("Foo"),
                                         typeGeneratorPass.stringLiteralExpression("Bar"))
                                       );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["stringType"],
        ["typeForPair", 0, 1],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from subtraction",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.subtractionExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"),
                                         typeGeneratorPass.numericLiteralExpression("2"))
                                       );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["typeForNumericExpression", 1],
        ["typeForPair", 2, 3],
        ["typeForGlobal", "A"],
        ["typeForPair", 4, 5],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from multiplication",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.multiplicationExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"),
                                         typeGeneratorPass.numericLiteralExpression("2"))
                                       );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["typeForNumericExpression", 1],
        ["typeForPair", 2, 3],
        ["typeForGlobal", "A"],
        ["typeForPair", 4, 5],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from division",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.divisionExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"),
                                         typeGeneratorPass.numericLiteralExpression("2"))
                                       );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["typeForNumericExpression", 1],
        ["typeForPair", 2, 3],
        ["typeForGlobal", "A"],
        ["typeForPair", 4, 5],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from ABS",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.absBuiltinExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from CINT",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.cintBuiltinExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from FIX",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.fixBuiltinExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from INT",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.intBuiltinExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from LEFT$",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.leftzBuiltinExpression(
                                         typeGeneratorPass.stringLiteralExpression("something"),
                                         typeGeneratorPass.numericLiteralExpression("1"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["numericType"],
        ["typeForStringExpression", 0],
        ["typeForNumericExpression", 1],
        ["stringType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 4, 5],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from RIGHT$",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.rightzBuiltinExpression(
                                         typeGeneratorPass.stringLiteralExpression("something"),
                                         typeGeneratorPass.numericLiteralExpression("1"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["numericType"],
        ["typeForStringExpression", 0],
        ["typeForNumericExpression", 1],
        ["stringType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 4, 5],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from LEN",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.lenBuiltinExpression(
                                         typeGeneratorPass.stringLiteralExpression("something"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["typeForStringExpression", 0],
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from STR$",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.strzBuiltinExpression(
                                         typeGeneratorPass.numericLiteralExpression("1001"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["stringType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from VAL",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.valBuiltinExpression(
                                         typeGeneratorPass.stringLiteralExpression("100"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["typeForStringExpression", 0],
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from RANDOM",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.randomBuiltinExpression(
                                         typeGeneratorPass.numericLiteralExpression("1"),
                                         typeGeneratorPass.numericLiteralExpression("100"))
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["typeForNumericExpression", 1],
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 4, 5],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment from PI",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.piBuiltinExpression()
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForGlobal", "A"],
        ["typeForPair", 0, 1],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Subroutine declaration",
      run: function() {
        typeGeneratorPass.beginSubroutine("FOO", []);
        typeGeneratorPass.endSubroutine();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["registerSubroutineDefinition", "FOO", []],
        ["typeForVoidReturnStatement", "FOO"],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Subroutine with variable return",
      run: function() {
        typeGeneratorPass.beginSubroutine("FOO", ["BIZ", "BANG"]);
        typeGeneratorPass.returnStatement(
          typeGeneratorPass.variableExpression("BAR")
        );
        typeGeneratorPass.endSubroutine();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["registerSubroutineDefinition", "FOO", ["BIZ", "BANG"]],
        ["localVariableDefined", "FOO", "BAR"],
        ["typeForGlobal", "BAR"],
        ["typeForReturnStatement", "FOO", 2],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Subroutine with string return",
      run: function() {
        typeGeneratorPass.beginSubroutine("FOO", ["BAR", "BIZ", "BAZ"]);
        typeGeneratorPass.returnStatement(
          typeGeneratorPass.stringLiteralExpression("BAR")
        );
        typeGeneratorPass.endSubroutine();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["registerSubroutineDefinition", "FOO", ["BAR", "BIZ", "BAZ"]],
        ["stringType"],
        ["typeForReturnStatement", "FOO", 1],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Subroutine with numeric return",
      run: function() {
        typeGeneratorPass.beginSubroutine("FOO", ["BAR"]);
        typeGeneratorPass.returnStatement(
          typeGeneratorPass.numericLiteralExpression("700")
        );
        typeGeneratorPass.endSubroutine();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["registerSubroutineDefinition", "FOO", ["BAR"]],
        ["numericType"],
        ["typeForReturnStatement", "FOO", 1],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Call statement",
      run: function() {
        typeGeneratorPass.callSubroutine("FOO", []);
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForCallSubroutine", "FOO", []],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Call statement with variable expression",
      run: function() {
        typeGeneratorPass.callSubroutine("FOO",
                                         [typeGeneratorPass.variableExpression("NONE")]
                                        );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "NONE"],
        ["typeForCallSubroutine", "FOO", [0]],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Call statement with multiple literal parameters",
      run: function() {
        typeGeneratorPass.callSubroutine("FOO",
                                         [
                                           typeGeneratorPass.numericLiteralExpression("12"),
                                           typeGeneratorPass.stringLiteralExpression("bar")
                                         ]
                                        );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["stringType"],
        ["typeForCallSubroutine", "FOO", [0, 1]],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Call expression",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.callSubroutineExpression("FOO", [])
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForCallSubroutine", "FOO", []],
        ["typeForGlobal", "A"],
        ["typeForPair", 0, 1],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Call expression with variable param",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.callSubroutineExpression("FOO", [
                                         typeGeneratorPass.variableExpression("BAR")
                                       ])
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "BAR"],
        ["typeForCallSubroutine", "FOO", [0]],
        ["typeForGlobal", "A"],
        ["typeForPair", 1, 2],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Call expression with two params",
      run: function() {
        typeGeneratorPass.letStatement("A",
                                       typeGeneratorPass.callSubroutineExpression("FOO", [
                                         typeGeneratorPass.numericLiteralExpression("1"),
                                         typeGeneratorPass.stringLiteralExpression("bar")
                                       ])
                                      );
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["stringType"],
        ["typeForCallSubroutine", "FOO", [0, 1]],
        ["typeForGlobal", "A"],
        ["typeForPair", 2, 3],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "IF with Call expressions",
      run: function() {
        typeGeneratorPass.ifStatement(
          typeGeneratorPass.boolNotEqualExpression(
            typeGeneratorPass.callSubroutineExpression(
              "PLUSONE",
              typeGeneratorPass.parenExpression(
                typeGeneratorPass.callSubroutineExpression(
                  "PLUSONE",
                  typeGeneratorPass.numericLiteralExpression("1")
                ))),
            typeGeneratorPass.callSubroutineExpression(
              "PLUSONE",
              typeGeneratorPass.numericLiteralExpression(2)
            )));
        typeGeneratorPass.endIf();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["typeForCallSubroutine", "PLUSONE", 0],
        ["typeForCallSubroutine", "PLUSONE", 1],
        ["numericType"],
        ["typeForCallSubroutine", "PLUSONE", 3],
        ["typeForPair", 2, 4],
        ["boolType"],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment of multiply, then add",
      run: function() {
        typeGeneratorPass.letStatement(
          "A",
          typeGeneratorPass.additionExpression(
            typeGeneratorPass.numericLiteralExpression("88"),
            typeGeneratorPass.multiplicationExpression(
              typeGeneratorPass.numericLiteralExpression("66"),
              typeGeneratorPass.numericLiteralExpression("77")
            )));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["numericType"],
        ["numericType"],
        ["typeForNumericExpression", 1],
        ["typeForNumericExpression", 2],
        ["typeForPair", 3, 4],
        ["typeForPair", 0, 5],
        ["typeForGlobal", "A"],
        ["typeForPair", 6, 7],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "Assignment of divide, then subtract",
      run: function() {
        typeGeneratorPass.letStatement(
          "A",
          typeGeneratorPass.subtractionExpression(
            typeGeneratorPass.divisionExpression(
              typeGeneratorPass.numericLiteralExpression("66"),
              typeGeneratorPass.numericLiteralExpression("77")
            ),
            typeGeneratorPass.numericLiteralExpression("88")
          ));
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["numericType"],
        ["typeForNumericExpression", 0],
        ["typeForNumericExpression", 1],
        ["typeForPair", 2, 3],
        ["numericType"],
        ["typeForNumericExpression", 4],
        ["typeForNumericExpression", 5],
        ["typeForPair", 6, 7],
        ["typeForGlobal", "A"],
        ["typeForPair", 8, 9],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "IF with string comparision",
      run: function() {
        typeGeneratorPass.ifStatement(
          typeGeneratorPass.boolEqualExpression(
            typeGeneratorPass.stringLiteralExpression("a"),
            typeGeneratorPass.variableExpression("SEVEN")
          ));
        typeGeneratorPass.endIf();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["stringType"],
        ["typeForGlobal", "SEVEN"],
        ["typeForPair", 0, 1],
        ["boolType"],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "IF with greater than comparision",
      run: function() {
        typeGeneratorPass.ifStatement(
          typeGeneratorPass.boolGreaterExpression(
            typeGeneratorPass.variableExpression("Q"),
            typeGeneratorPass.numericLiteralExpression("77")
          ));
        typeGeneratorPass.endIf();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "Q"],
        ["numericType"],
        ["typeForPair", 0, 1],
        ["boolType"],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "IF with less than comparision",
      run: function() {
        typeGeneratorPass.ifStatement(
          typeGeneratorPass.boolLessExpression(
            typeGeneratorPass.variableExpression("Q"),
            typeGeneratorPass.variableExpression("Z")
          ));
        typeGeneratorPass.endIf();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "Q"],
        ["typeForGlobal", "Z"],
        ["typeForPair", 0, 1],
        ["boolType"],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "IF with greater than or equal comparision",
      run: function() {
        typeGeneratorPass.ifStatement(
          typeGeneratorPass.boolGreaterOrEqualExpression(
            typeGeneratorPass.variableExpression("Q"),
            typeGeneratorPass.numericLiteralExpression("77")
          ));
        typeGeneratorPass.endIf();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["typeForGlobal", "Q"],
        ["numericType"],
        ["typeForPair", 0, 1],
        ["boolType"],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "IF with less than or equal comparision",
      run: function() {
        typeGeneratorPass.ifStatement(
          typeGeneratorPass.boolLessOrEqualExpression(
            typeGeneratorPass.numericLiteralExpression("33"),
            typeGeneratorPass.numericLiteralExpression("44")
          ));
        typeGeneratorPass.endIf();
        typeGeneratorPass.finalize();
      },
      calls: [
        ["numericType"],
        ["numericType"],
        ["typeForPair", 0, 1],
        ["boolType"],
        ["validate"]
      ],
      errors: []
    },
    {
      description: "IF with boolean OR and AND",
      run: function() {
        typeGenerator.ifStatement(
          typeGenerator.boolOrExpression(
            typeGenerator.boolGreaterExpression(
              typeGeneratorPass.additionExpression(
                typeGeneratorPass.numericLiteralExpression("66"),
                typeGeneratorPass.numericLiteralExpression("77")
              ),
              typeGeneratorPass.subtractionExpression(
                typeGeneratorPass.numericLiteralExpression("66"),
                typeGeneratorPass.numericLiteralExpression("77")
              )
            ),
            typeGeneratorPass.boolGreaterExpression(
              typeGeneratorPass.

      },
      calls: [],
      errors:[]
    }
  ];


  function expectationToTestFunc(expectation) {
    return expectation.run;
  }

  function expectationText(expectation) {
    return expectation.run.toString();
  }

  function getCallLog() {
    return typeManager.getLog();
  }

  function getErrorLog() {
    return logger.getLog();
  }


  var tester = MatchingTester(display, setup, expectations, expectationToTestFunc, expectationText, getCallLog, getErrorLog);
  return tester;
}
